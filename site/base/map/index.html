<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>map集合 - TopJava</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "map\u96c6\u5408";
    var mkdocs_page_input_path = "base\\map.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> TopJava</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">基础</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../datatype/">Java中的数据类型</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../classload/">Java中类加载机制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../string/">String字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../collections/">集合</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../valuetransfer/">值传递和引用传递</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">map集合</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#hashmap">hashmap</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#2">初始化大小为什么时 2 的次幂？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#075">为什么加载因子要设置成 0.75？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#hash-hashmap">什么是 hash 冲突，hashmap 是怎么处理的？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#hash-hash-hash">hash 表采用什么算法计算出 hash 值?还有什么算法可以计算出 hash 值？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#17-hashmap">1.7 中的 HashMap</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#hashmap_1">hashmap 的死锁问题？</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#18-hashmap">1.8 中的 HashMap</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#7">为什么链表长度大于等于 7 时，就要转成红黑树？</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#17">1.7 源码分析</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-17-put">1. 1.7 中 put 方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-17-12-null">2. 1.7 源码中，并不仅仅是数组达到阈值 12 就进行扩容，还要判断要存储的位置是否为 null</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-17">3. 1.7 中使用头插法，拉链法进行存储</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4-17">4. 1.7 扩容方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5-17-get">5. 1.7 中的 get 方法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#18">1.8 源码分析</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-18-put">1. 1.8 中的 put 方法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#concurrenthashmap">ConcurrentHashMap</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#17-concurrenthashmap">1.7 中的 ConcurrentHashMap</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#18-concurrenthashmap">1.8 中的 ConcurrentHashMap</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../list/">list容器</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">并发</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../concurrent/">并发的定义</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../concurrent/lock/">分布式锁</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../concurrent/singleton/">单例模式</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../concurrent/cas/">CAS</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../concurrent/queue/">阻塞队列</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">JVM和GC</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../jvm/">jvm基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../jvm/interview/">jvm面试题</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">MQ消息队列</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../mq/">消息队列</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">nosql数据库</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../nosql/redis/">redis</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">spring框架</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../spring/">spring框架基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../spring/interview/">面实题集合</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">mybatis框架</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../mybatis/">基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../mybatis/interview/">面试题</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">关系型数据库</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../mysql/">mysql</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">zookeeper</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../zookeeper/">基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../zookeeper/interview/">面试题</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">oauth2.0 微服务认证授权</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../oauth20/authserver/">spring cloud构建认证服务</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">TopJava</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>基础 &raquo;</li>
        
      
    
    <li>map集合</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/BruceAKABear/TopJava/edit/master/docs/base/map.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="map">map 集合<a class="headerlink" href="#map" title="Permanent link">&para;</a></h1>
<p>map 是以 key-value 的形式存储数组的数据结构</p>
<h2 id="hashmap">hashmap<a class="headerlink" href="#hashmap" title="Permanent link">&para;</a></h2>
<ol>
<li>默认大小 16，2 的 4 次方。最大大小 2 的 30 次方，大概在 10 亿 7 千万多</li>
<li>负载因子 0.75</li>
</ol>
<p>存储数据时，将 hash 值，key，value 等封装成一个对象</p>
<h3 id="2">初始化大小为什么时 2 的次幂？<a class="headerlink" href="#2" title="Permanent link">&para;</a></h3>
<p>因为这样的话能加快 hash 值得计算</p>
<h3 id="075">为什么加载因子要设置成 0.75？<a class="headerlink" href="#075" title="Permanent link">&para;</a></h3>
<p>过小浪费空间，过大哈希碰撞概率大</p>
<h3 id="hash-hashmap">什么是 hash 冲突，hashmap 是怎么处理的？<a class="headerlink" href="#hash-hashmap" title="Permanent link">&para;</a></h3>
<p>当，我们对存入的 key 进行 hash 计算以后，得到的 hash 桶的位置和其他的 key 计算出来的 hash 桶的位置相同的时候，这就是 hash 冲突（哈希碰撞）。存在链表上</p>
<h3 id="hash-hash-hash">hash 表采用什么算法计算出 hash 值?还有什么算法可以计算出 hash 值？<a class="headerlink" href="#hash-hash-hash" title="Permanent link">&para;</a></h3>
<p>采用 key 的 hashcode 值，按位异或 key 的哈希值结合数组的长度进行无符号的右移(&gt;&gt;&gt;)，也就是 key 的哈希值无符号右移 16 位。
可以计算哈希值的算法有：</p>
<ol>
<li>取余</li>
<li>平方取中</li>
<li>伪随机数法</li>
</ol>
<p>其他计算方式，效率比较低，尤其是取余底层是一直减。采用异或速度是非常快的。</p>
<h3 id="17-hashmap">1.7 中的 HashMap<a class="headerlink" href="#17-hashmap" title="Permanent link">&para;</a></h3>
<p>底层原理树数组加链表，数组为 entry 数组，实现了 mep.entry</p>
<h4 id="hashmap_1">hashmap 的死锁问题？<a class="headerlink" href="#hashmap_1" title="Permanent link">&para;</a></h4>
<h3 id="18-hashmap">1.8 中的 HashMap<a class="headerlink" href="#18-hashmap" title="Permanent link">&para;</a></h3>
<ol>
<li>链表转树的阈值为 8</li>
<li>树转链表的阈值为 6</li>
<li>树转换数组大小阈值 64</li>
</ol>
<p>底层实现原理是数组加链表加红黑树,数组为 node 数组，也实现了 map.entry</p>
<h4 id="7">为什么链表长度大于等于 7 时，就要转成红黑树？<a class="headerlink" href="#7" title="Permanent link">&para;</a></h4>
<p>首先，不是说链表的长度大于 8 就进行树的转换。源码里面写了只有当，数组的长度大于 64，同时，链表的长度大于 8，那么才进行树的转换。
<strong>为什么呢？</strong>红黑树在插入数据得时候会进行左旋右旋得操作，导致插入比较慢，虽然查询快，但是其实性能是有缺陷的。所以没有上来就使用红黑树，所以源码里面在数组没有大于 64 的时候，如果链表长度大于 8 其实是进行了数组的扩容。只有当数组长度大于 64 且链表长度大于 8 以后，才进行链表转红黑树。</p>
<h2 id="17">1.7 源码分析<a class="headerlink" href="#17" title="Permanent link">&para;</a></h2>
<h3 id="1-17-put">1. 1.7 中 put 方法<a class="headerlink" href="#1-17-put" title="Permanent link">&para;</a></h3>
<pre><code class="java">    public V put(K key, V value) {
        //如果哈希表为空，则初始化entry数组
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        //如果key是null值，直接调用putnull方法
        if (key == null)
        {
            return putForNullKey(value);
        }
        //计算key的哈希值
        int hash = hash(key);
        //计算key在hash桶中的位置
        int i = indexFor(hash, table.length);
        //根据桶的位置，获取原有值。如果不为空，则遍历所有的链表
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            //如果链表中hash相同同时key相同，则替换原有值
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        //如果原有值为空，那么直接添加
        addEntry(hash, key, value, i);
        return null;
    }
</code></pre>

<h3 id="2-17-12-null">2. 1.7 源码中，并不仅仅是数组达到阈值 12 就进行扩容，还要判断要存储的位置是否为 null<a class="headerlink" href="#2-17-12-null" title="Permanent link">&para;</a></h3>
<p>源码：</p>
<pre><code class="java">//添加entry对象方法
void addEntry(int hash, K key, V value, int bucketIndex) {
    //判断阈值是否大于等于，同时哈希表上不为null
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }

</code></pre>

<h3 id="3-17">3. 1.7 中使用头插法，拉链法进行存储<a class="headerlink" href="#3-17" title="Permanent link">&para;</a></h3>
<pre><code class="java">  //添加对象方法
  void createEntry(int hash, K key, V value, int bucketIndex) {
        //首先获取哈希表中的对象
        Entry&lt;K,V&gt; e = table[bucketIndex];
        //然后添加对象，添加对象在头部
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
        size++;
    }

</code></pre>

<h3 id="4-17">4. 1.7 扩容方法<a class="headerlink" href="#4-17" title="Permanent link">&para;</a></h3>
<pre><code class="java">//resize方法。1.产生新的数组，2.将老数组中的对象重新进行hash放置于芯数组中
  void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        Entry[] newTable = new Entry[newCapacity];
        //第二个参数控制是否需要rehash
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }
</code></pre>

<p>transfer 方法将老数组中的值重新计算 hash 赋值到新数组中</p>
<pre><code class="java">    void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        //遍历老数组
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
</code></pre>

<h3 id="5-17-get">5. 1.7 中的 get 方法<a class="headerlink" href="#5-17-get" title="Permanent link">&para;</a></h3>
<pre><code class="java">    public V get(Object key) {
        if (key == null)
            return getForNullKey();
        Entry&lt;K,V&gt; entry = getEntry(key);

        return null == entry ? null : entry.getValue();
    }
</code></pre>

<pre><code class="java">    final Entry&lt;K,V&gt; getEntry(Object key) {
        if (size == 0) {
            return null;
        }

        int hash = (key == null) ? 0 : hash(key);
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }


</code></pre>

<h2 id="18">1.8 源码分析<a class="headerlink" href="#18" title="Permanent link">&para;</a></h2>
<h3 id="1-18-put">1. 1.8 中的 put 方法<a class="headerlink" href="#1-18-put" title="Permanent link">&para;</a></h3>
<pre><code class="java">
   public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //判断有无初始化，然后初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //计算index，如果获得index的数组为null那么直接将node对象放在数组上
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            //如果不为null,判断hash是否相同，判断key如果相同然后将新值替换旧值
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
                //如果是树类型，那么就调用树添加方法
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
                //遍历链表，将新node对象放置在末尾
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //如果长度大于等于8那么就进行树转换
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

</code></pre>

<h2 id="concurrenthashmap">ConcurrentHashMap<a class="headerlink" href="#concurrenthashmap" title="Permanent link">&para;</a></h2>
<h3 id="17-concurrenthashmap">1.7 中的 ConcurrentHashMap<a class="headerlink" href="#17-concurrenthashmap" title="Permanent link">&para;</a></h3>
<p>分段锁加 cas</p>
<p>当我们 put 的时候，根据 key 的 hash 值，先去获取 segment 数组下标，获取到 segment 对象,如果segment对象为空，那么就new一个segement对象，相关的数据从0相关的属性，segment 对象内部有一个小的 hashentry 数组，也就是一个小的 hahsmap.然后根据 hash 计算出哈希桶的位置，去 put 数据，这个过程中呢会使用非公平锁 unfairLock.</p>
<h3 id="18-concurrenthashmap">1.8 中的 ConcurrentHashMap<a class="headerlink" href="#18-concurrenthashmap" title="Permanent link">&para;</a></h3>
<p>底层使用 synchronized 和 cas</p>
<p>和hashmap很像，在获取时使用了cas,在添加时使用了sync</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../list/" class="btn btn-neutral float-right" title="list容器">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../valuetransfer/" class="btn btn-neutral" title="值传递和引用传递"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/BruceAKABear/TopJava/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../valuetransfer/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../list/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
