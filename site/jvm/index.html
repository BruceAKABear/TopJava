<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>jvm基础知识 - TopJava</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "jvm\u57fa\u7840\u77e5\u8bc6";
    var mkdocs_page_input_path = "jvm\\index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> TopJava</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">简介</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">基础</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../base/datatype/">Java中的数据类型</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../base/classload/">Java中类加载机制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../base/string/">String字符串</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../base/collections/">集合</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../base/valuetransfer/">值传递和引用传递</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../base/map/">map集合</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../base/list/">list容器</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">并发</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../concurrent/">并发的定义</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../concurrent/lock/">分布式锁</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../concurrent/singleton/">单例模式</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../concurrent/cas/">CAS</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../concurrent/queue/">阻塞队列</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">JVM和GC</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">jvm基础知识</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">类加载器</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">双亲委派机制和沙箱安全</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">自定义类加载器</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#execution-engine">执行引擎 Execution Engine</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#native">native 方法</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">程序计数器</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">方法区</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">虚拟机栈</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">保存什么？</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_8">堆</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#jvm">JVM 内存划分</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_9">堆内存划分</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gc-roots">GC ROOTS 对象</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#4">4 大垃圾回收算法七大垃圾回收器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_10">垃圾回收算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_11">垃圾收集器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#jvm_1">jvm 调优</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_12">前提知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">常用参数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gc">gc 日志</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">死锁定位</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#jmm-java">JMM java 内存模型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#java">Java 加载执行顺序</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="interview/">jvm面试题</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">MQ消息队列</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../mq/">消息队列</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">nosql数据库</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../nosql/redis/">redis</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">spring框架</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../spring/">spring框架基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../spring/interview/">面实题集合</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">mybatis框架</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../mybatis/">基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../mybatis/interview/">面试题</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">关系型数据库</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../mysql/">mysql</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">zookeeper</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../zookeeper/">基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../zookeeper/interview/">面试题</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">oauth2.0 微服务认证授权</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../oauth20/authserver/">spring cloud构建认证服务</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">TopJava</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>JVM和GC &raquo;</li>
        
      
    
    <li>jvm基础知识</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/BruceAKABear/TopJava/edit/master/docs/jvm/index.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="jvm-java">jvm Java 虚拟机<a class="headerlink" href="#jvm-java" title="Permanent link">&para;</a></h1>
<p>栈管运行，堆管存储。</p>
<h2 id="_1">类加载器<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>字节码加载以后放在方法区。类加载器只负责 class 文件的加载，是否可运行由执行引擎决定。</p>
<ul>
<li>
<p>启动类加载器 Bootstrap 使用 c++语言写的。其他都是 Java 写的，bootstrap 负责加载 jre/lib/rt.jar,打印的话为 null.</p>
</li>
<li>
<p>扩展类加载器 ExtClassLoader,负责加载 jre/lib/ext/.jar.其父类加载器也是 null</p>
</li>
<li>应用加载器 AppClassLoader</li>
</ul>
<pre><code class="java">
        ClassLoaderDemo object =  new ClassLoaderDemo();
        System.out.println(object.getClass().getClassLoader());
        System.out.println(object.getClass().getClassLoader().getParent());
        System.out.println(object.getClass().getClassLoader().getParent().getParent());
        //输出为
        sun.misc.Launcher$AppClassLoader@18b4aac2
        sun.misc.Launcher$ExtClassLoader@7c53a9eb
        null
</code></pre>

<h2 id="_2">双亲委派机制和沙箱安全<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>加载类的时候委托父类加载,如果父类已经加载那么就不在加载，保证不污染自带类的也叫沙箱机制。</p>
<ul>
<li>如果自定义一个 java.lang.String 类的话运行会报安全性异常</li>
</ul>
<pre><code class="java">
package java.lang;

public class String {

    public static void main(String[] args) {
        System.out.println(&quot;hello&quot;);
    }
}
//结果
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
Disconnected from the target VM, address: '127.0.0.1:8616', transport: 'socket'
[ERROR] Command execution failed.
org.apache.commons.exec.ExecuteException: Process exited with an error: 1 (Exit value: 1)


//如果不在自定义的类中调用，自己写的string类根本就不会加载
</code></pre>

<h2 id="_3">自定义类加载器<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>继承 ClassLoader 重写 findClass 方法。findClass 方法和 loadClass 方法之间有什么区别的？如果不想打破双亲委派机制，那么直接使用重写 findClass 方法，loadClass 方法可以不双亲委派直接加载类，使用 loadClass 方法的话可以实现热部署</p>
<h2 id="execution-engine">执行引擎 Execution Engine<a class="headerlink" href="#execution-engine" title="Permanent link">&para;</a></h2>
<h2 id="native">native 方法<a class="headerlink" href="#native" title="Permanent link">&para;</a></h2>
<p>本地方法栈中是 native，没有垃圾回收，很小只有 10 来 KB，比如 thread 类中的 start0()方法</p>
<h2 id="_4">程序计数器<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<p>cpu 中的寄存器，是当前线程执行字节码的行号指示器。如果 native 方法，计数器是空的，因为 native 方法不是 Java 的。用来完成分支循环跳转异常处理等等。</p>
<h2 id="_5">方法区<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p>很少垃圾回收，线程共享。是存放类的结构信息，也就是模板。如常量池字段方法数据构造函数普通方法等字节码内容，</p>
<p>方法区是规范，不同虚拟机实现不同。如永久代和原空间</p>
<p>存储：类结构信息、普通常量、静态常量、编译器编译后的代码等。也叫非堆内存，1.7 之前的永久代是方法区的一个实现而已。</p>
<h2 id="_6">虚拟机栈<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p>没有 gc，栈溢出是错误不是异常</p>
<h3 id="_7">保存什么？<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>8 中基本类型，对象的引用，实例方法的都是在栈中分配。Java 中方法叫做栈帧</p>
<h2 id="_8">堆<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h2>
<p>规范上分为三代，实际上新生代和老年代是物理连续的，元空间不在堆上</p>
<ul>
<li>
<p>新生代 1/3</p>
</li>
<li>
<p>eden 区 8</p>
</li>
<li>s0(from) 1</li>
<li>
<p>s1(to) 1</p>
</li>
<li>
<p>老年代 2/3</p>
</li>
<li>
<p>15 次垃圾回收以后进入</p>
</li>
<li>
<p>永久代</p>
</li>
<li>
<p>1.8 之后永久代不在 jvm 内存中，二是直接使用物理内存，默认大小为物理内存的 1/4</p>
</li>
</ul>
<pre><code class="java">
Heap
 PSYoungGen      total 153088K, used 7895K [0x0000000715800000, 0x0000000720280000, 0x00000007c0000000)
  eden space 131584K, 6% used [0x0000000715800000,0x0000000715fb5dc8,0x000000071d880000)
  from space 21504K, 0% used [0x000000071ed80000,0x000000071ed80000,0x0000000720280000)
  to   space 21504K, 0% used [0x000000071d880000,0x000000071d880000,0x000000071ed80000)
 ParOldGen       total 349696K, used 0K [0x00000005c0800000, 0x00000005d5d80000, 0x0000000715800000)
  object space 349696K, 0% used [0x00000005c0800000,0x00000005c0800000,0x00000005d5d80000)
 Metaspace       used 3028K, capacity 4556K, committed 4864K, reserved 1056768K
  class space    used 319K, capacity 392K, committed 512K, reserved 1048576K
</code></pre>

<h2 id="jvm">JVM 内存划分<a class="headerlink" href="#jvm" title="Permanent link">&para;</a></h2>
<p>堆栈方法区程序计数器</p>
<p>栈、程序计数器线程私有
堆、方法区线程共享，存在垃圾回收</p>
<h3 id="_9">堆内存划分<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>新生代、老年代、持久代（1.8 没有老年代）
新生代：Eden 区和 servivor，servivor 区使用复制算法，每次只能使用一般的内存</p>
<h2 id="gc-roots">GC ROOTS 对象<a class="headerlink" href="#gc-roots" title="Permanent link">&para;</a></h2>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态类属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ol>
<h2 id="4">4 大垃圾回收算法七大垃圾回收器<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p>jvm 采用分代回收算法。1. 在次数上 young 区收集比较频繁，2.old 区收集比较少，3.基本上不动元空间</p>
<p>默认 15 次 GC 存在老年代，jdk8 定死了 15。gc 不是三块区域一起回收，主要发生在 young 区</p>
<h3 id="_10">垃圾回收算法<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<ol>
<li>引用计数算法</li>
<li>标记清除算法：老年代使用，最大的问题会产生内存碎片，两次扫描耗时，有 stw ，标记要清除的对象，然后统一进行回收</li>
<li>标记整理算法：老年代使用，和标记清除混合使用。两次扫描，移动对象需要耗时，效率低于复制算法。工程上是使用标记清除，到达一定条件后进行整理也叫标记清除整理算法</li>
<li>复制算法：young 区使用复制算法，minorgc 会把 eden 区中对象移到 survivor 区中，如果 survivor 区放不下，那么剩下的活的对象就会被异动到 old 区，一旦收集完成 eden 区就会变成空。优点不会产生内存碎片， 缺点耗空间</li>
</ol>
<h3 id="_11">垃圾收集器<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<h2 id="jvm_1">jvm 调优<a class="headerlink" href="#jvm_1" title="Permanent link">&para;</a></h2>
<h3 id="_12">前提知识<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>Java 将内存抽象为 Runtime 对象,通过 Runtime.getRuntime()获取</p>
<p>java 虚拟机参数分为</p>
<ul>
<li>标准参数如(-) -version</li>
<li>
<p>非标准参数(-XX)</p>
</li>
<li>
<p>布尔型，用加号标识开启减号标识关闭：</p>
</li>
<li>
<p>-XX:+PrintGCDetails 开启打印 gc 日志</p>
</li>
<li>-XX:+PrintCommandLineFlags 打印启动配置信息</li>
<li>-XX:NewRatio=2 设置新生代和老年代的比例，值直接代表老年代占比，剩下的 1 就是新生代的。</li>
<li>-XX:ServivorRatio=8 设置 endn 和 servivor 的比例，8:1:1</li>
<li>
<p>-XX:MaxTenuringThreshold=15 设置垃圾新生代到老年代要经过的 gc 次数，默认是 15 次。如果设置 0 则不经过 servivor 直接进入老年代。必须设置在 0-15 之间</p>
</li>
<li>
<p>key-vlue 键值型-XX:InnitialHeapSize=1m</p>
</li>
<li>-Xms 堆最小值</li>
<li>-Xmx 堆最大值</li>
<li>-Xss 单个线程栈大小，一般 512k-1024k。初始值查询出来的话是 0，所以如果查询出来 0 就代表是初始值。linux 默认是 1024k</li>
<li>-Xmn 设置新生代大小，默认不用调试用默认值</li>
<li>-XX:MetaspaceSize=1024m,元空间试用操作系统物理内存，默认情况 jdk 只分配了 21MB</li>
</ul>
<pre><code class="java">
    public static void main(String[] args) {
        //剩余堆内存
        System.out.println(Runtime.getRuntime().freeMemory());
        //处理器个数
        System.out.println(Runtime.getRuntime().availableProcessors());
        //最大内存，默认是系统的1/4
        System.out.println(Runtime.getRuntime().maxMemory());
        //最小堆内存，默认是系统内存的1/64
        System.out.println(Runtime.getRuntime().totalMemory());
    }
</code></pre>

<p><strong>实际线上必须将最小内存和最大内存设置为一样,避免 gc 和应用争抢内存浪费性能</strong></p>
<h3 id="_13">常用参数<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<ul>
<li>-XX:+PrintCommandLineFlags
  打印 jvm 的启动参数</li>
<li>-Xms 等价于-XX:InitialHeadSize
  设置堆最小内存，默认情况下为物理内存的 1/64</li>
<li>-Xmx 等价于-XX:MaxHeapSize
  设置堆内存的最大值。默认情况下为物理内存的 1/4</li>
<li>
<p>-XX:+PrintGcDetails
  打印 gc 日志</p>
</li>
<li>
<p>jinfo 查询正在运行的服务参数
  可以使用 jinfo pid 也可以使用 jinfo flag(s) pid</p>
</li>
</ul>
<h3 id="gc">gc 日志<a class="headerlink" href="#gc" title="Permanent link">&para;</a></h3>
<p>eden 区 minor gc old 区发生 major gc 也叫 full gc，fullgc 慢 8-10 倍，为什么慢？因为 full gc 扫描空间比较大</p>
<pre><code class="java">
[GC (Allocation Failure) [PSYoungGen: 1000K-&gt;488K(1024K)] 1016K-&gt;576K(1536K), 0.0006887 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

[Full GC (Ergonomics) [PSYoungGen: 649K-&gt;137K(1024K)] [ParOldGen: 408K-&gt;408K(512K)] 1058K-&gt;545K(1536K), [Metaspace: 3020K-&gt;3020K(1056768K)], 0.0041367 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre>

<h3 id="_14">死锁定位<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<p>java 模拟</p>
<pre><code class="java">public class DeadLockDemo {

    public static void main(String[] args) {
        String lockA = &quot;lockA&quot;;
        String lockB = &quot;lockB&quot;;
        new Thread(new res(lockA, lockB), &quot;aaaaaaaaaaaa&quot;).start();
        new Thread(new res(lockB, lockA), &quot;bbbbbbbbbbbb&quot;).start();
    }
}

class res extends Thread {
    private String lockA;
    private String lockB;
    public res(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }
    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(&quot;获得锁&quot; + lockA + &quot;尝试获取&quot; + lockB);
            try {
                TimeUnit.SECONDS.sleep(3);
                synchronized (lockB) {
                    System.out.println(&quot;获得锁&quot; + lockB);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

</code></pre>

<p>实操过程：</p>
<ul>
<li>
<ol>
<li>使用 jps 查看进程编号(linux 和 windows 通用)</li>
</ol>
</li>
</ul>
<pre><code class="java">jps -l

//打印信息
PS C:\Users\bear\IdeaProjects\jvmdemo&gt; jps -l
11920 org.jetbrains.jps.cmdline.Launcher
12448 org.jetbrains.idea.maven.server.RemoteMavenServer36
9424
11044
15736 org.codehaus.classworlds.Launcher
5788 pro.dengyi.DeadLockDemo
6940 sun.tools.jps.Jps
7548 org/netbeans/Main

</code></pre>

<ul>
<li>根据自己项目的包名使用 jstack 命令查看栈信息</li>
</ul>
<pre><code class="java">PS C:\Users\bear\IdeaProjects\jvmdemo&gt; jstack 5788
//打印信息
2020-06-25 22:49:12
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.241-b07 mixed mode):

&quot;DestroyJavaVM&quot; #17 prio=5 os_prio=0 tid=0x0000000003652800 nid=0x838 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;bbbbbbbbbbbb&quot; #16 prio=5 os_prio=0 tid=0x00000000277ae800 nid=0x1de4 waiting for monitor entry [0x000000002866e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at pro.dengyi.res.run(DeadLockDemo.java:29)
        - waiting to lock &lt;0x00000007159a77d0&gt; (a java.lang.String)
        - locked &lt;0x00000007159a7808&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)

&quot;aaaaaaaaaaaa&quot; #14 prio=5 os_prio=0 tid=0x00000000277ab000 nid=0xf60 waiting for monitor entry [0x000000002856e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at pro.dengyi.res.run(DeadLockDemo.java:29)
        - waiting to lock &lt;0x00000007159a7808&gt; (a java.lang.String)
        - locked &lt;0x00000007159a77d0&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)

&quot;Service Thread&quot; #12 daemon prio=9 os_prio=0 tid=0x0000000027779800 nid=0x33cc runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;C1 CompilerThread2&quot; #11 daemon prio=9 os_prio=2 tid=0x00000000276f3000 nid=0xc8c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;C2 CompilerThread1&quot; #10 daemon prio=9 os_prio=2 tid=0x00000000276ea000 nid=0x2cf8 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;C2 CompilerThread0&quot; #9 daemon prio=9 os_prio=2 tid=0x00000000276e9000 nid=0x90c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;JDWP Command Reader&quot; #8 daemon prio=10 os_prio=0 tid=0x0000000027690800 nid=0x6ec runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;JDWP Event Helper Thread&quot; #7 daemon prio=10 os_prio=0 tid=0x000000002768d000 nid=0x14f4 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;JDWP Transport Listener: dt_socket&quot; #6 daemon prio=10 os_prio=0 tid=0x000000002767e800 nid=0x2a60 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x0000000027678800 nid=0x1dac waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x0000000026330000 nid=0x2444 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x000000000374c800 nid=0x2920 in Object.wait() [0x000000002766e000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0x0000000715808ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
        - locked &lt;0x0000000715808ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)

&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x000000002630a800 nid=0x10d8 in Object.wait() [0x000000002756f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0x0000000715806c00&gt; (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:502)
        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
        - locked &lt;0x0000000715806c00&gt; (a java.lang.ref.Reference$Lock)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

&quot;VM Thread&quot; os_prio=2 tid=0x00000000262e8000 nid=0x14e8 runnable

&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000003668000 nid=0xf30 runnable

&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x0000000003669800 nid=0x85c runnable

&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000366b800 nid=0xd84 runnable

&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000366e000 nid=0x3280 runnable

&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x00000000277a5000 nid=0x3734 waiting on condition

JNI global references: 1499


Found one Java-level deadlock:
=============================
&quot;bbbbbbbbbbbb&quot;:
  waiting to lock monitor 0x00000000037494f8 (object 0x00000007159a77d0, a java.lang.String),
  which is held by &quot;aaaaaaaaaaaa&quot;
&quot;aaaaaaaaaaaa&quot;:
  waiting to lock monitor 0x000000000374bd88 (object 0x00000007159a7808, a java.lang.String),
  which is held by &quot;bbbbbbbbbbbb&quot;

Java stack information for the threads listed above:
===================================================
&quot;bbbbbbbbbbbb&quot;:
        at pro.dengyi.res.run(DeadLockDemo.java:29)
        - waiting to lock &lt;0x00000007159a77d0&gt; (a java.lang.String)
        - locked &lt;0x00000007159a7808&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)
&quot;aaaaaaaaaaaa&quot;:
        at pro.dengyi.res.run(DeadLockDemo.java:29)
        - waiting to lock &lt;0x00000007159a7808&gt; (a java.lang.String)
        - locked &lt;0x00000007159a77d0&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
</code></pre>

<h2 id="jmm-java">JMM java 内存模型<a class="headerlink" href="#jmm-java" title="Permanent link">&para;</a></h2>
<h2 id="java">Java 加载执行顺序<a class="headerlink" href="#java" title="Permanent link">&para;</a></h2>
<p>new 对象时的加载顺序</p>
<ol>
<li>静态代码块优先执行，加载一次</li>
<li>普通代码块</li>
<li>构造方法</li>
<li>其他</li>
</ol>
<p><strong>父类构造方法，子类会在构造方法中调用</strong></p>
<p>代码研究：</p>
<pre><code class="java">
public class LoadFatcher {
    static {
        System.out.println(&quot;父类中的静态代码块&quot;);
    }
    //普通代码块又叫做构造块
    {
        System.out.println(&quot;父类中的普通代码块执行&quot;);
    }
    public LoadFatcher() {
        System.out.println(&quot;父类构造方法执行&quot;);
    }
}
class LoadSon extends LoadFatcher {
    static {
        System.out.println(&quot;子类中的静态代码块&quot;);
    }
    {
        System.out.println(&quot;子类中的普通代码块执行&quot;);
    }
    public LoadSon() {
        System.out.println(&quot;子类构造方法执行&quot;);
    }


    public static void main(String[] args) {
        LoadSon loadSon = new LoadSon();
        System.out.println(&quot;子类中的普通方法执行---------------&quot;);
        LoadSon loadSon1 = new LoadSon();
    }
}
//输出
父类中的静态代码块
子类中的静态代码块
父类中的普通代码块执行
父类构造方法执行
子类中的普通代码块执行
子类构造方法执行
子类中的普通方法执行---------------
父类中的普通代码块执行
父类构造方法执行
子类中的普通代码块执行
子类构造方法执行

</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="interview/" class="btn btn-neutral float-right" title="jvm面试题">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../concurrent/queue/" class="btn btn-neutral" title="阻塞队列"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/BruceAKABear/TopJava/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../concurrent/queue/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="interview/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
