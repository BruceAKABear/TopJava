# 分布式锁
当服务进行分布式部署时，因为服务不在同一个jvm所以不能使用jvm中的锁，因此要使用分布式锁。

## 分布式锁方案

1. 使用MySQL数据库的乐观锁
但是绝对不会使用
2. 使用redis
使用原生代码实现，或者使用redison实现
3. 使用zookeeper实现
zookeeper的znode节点，zookeeper create命令直接创建的时持久节点，粗分持久零时两种。


## 使用zookeeper构建分布式锁
思想：使用zookeeper创建零时节点，连接断开时，零时节点自动删除，其他线程进行抢占。如果创建成功说明获得锁，如果创建失败，说明未获得锁，zookeeper中只能创建一个节点，同名节点创建会失败。

### 方案实现步骤

# 什么是锁？


## 公平锁与非公平锁

公平体现在获取锁的概率是否相同，非公平锁可以争抢，公平锁按照顺序

非公平锁可能会导致线程优先级反转或饥饿

非公平锁吞吐量大，默认情况ReentrantLock时非公平锁，synchronized也是非公平锁

## 可重入锁和递归锁

可重入锁就是递归锁

同一线程内，外层函数或代码块获得锁以后，内层函数或代码块会自动获得锁

ReentrantLock/synchronized可重入锁

**作用可以防止死锁**


对于lock.lock();

只要成对出现，嵌套多少个都行。加锁几次就要解锁几次

## 自旋锁

获取锁过程不阻塞，利用do...while循环获取。不会线程上下文切换，但是循环会消耗cpu

## 独占锁（写锁）、共享锁（读锁）/也叫互斥锁

独占锁只能被某一个线程使用

共享锁能被所有线程使用


ReentrantLock/synchronized是独占锁

## 手写自旋锁

## countdownlatch/cyclicbarrier/semaphore